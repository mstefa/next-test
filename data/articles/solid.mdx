---
title: "Solid"
published_at: "2022-05-23"
excerpt: "Solid es un acr√≥nimo nemot√©cnico de cinco principios reconocidos para generar c√≥digo autodocumentado, flexible y mantenible. Estos cincos principios son una selecci√≥n de principios publicados por Robert C. Martin, en un art√≠culo del 2000 titulado Design Principles and Design Patterns."
cover_image: "path/to/where/image/is/stored"
---

Solid es un acr√≥nimo nemot√©cnico de cinco principios reconocidos para generar c√≥digo autodocumentado, flexible y mantenible. Estos cincos principios son una selecci√≥n de principios publicados por Robert C. Martin, uncle Bob para los amigos üòú, en un art√≠culo del 2000 titulado Design Principles and Design Patterns.

Si bien uncle Bob no invento estos principios, √©l fue quien los agrupo sistem√°ticamente. En su art√≠culo que cualquier aplicaci√≥n, por m√°s eficiente o exitosa que sea en su tarea, siempre va a sufrir cambios a lo largo de su vida √∫til pudiendo ir degrad√°ndose, si no se siguen ciertos lineamientos para evitarlo.

## Los Cinco principios

### Single Responsibility:

> ‚Äúnunca debe haber m√°s de una raz√≥n para que un m√≥dulo cambie‚Äù

Este es el principio m√°s sencillo de entender. Que haga una sola cosa, y la haga bien. Aunque es probable que diferentes personas pueden interpretarlo de diferente manera. Es decir, ¬øcomo definimos una responsabilidad √∫nica?



### Open/Closed Principle

> ‚ÄúUn m√≥dulo debe estar abierto para la extensi√≥n, pero cerrado para la modificaci√≥n‚Äù

El ejemplo m√°s tradicional es el siguiente. Supongamos que para un nuevo feature de nuestra app podemos reutilizar los m√©todos de una clase ya existente. Pero para nuestro nuevo caso tambi√©n necesitamos agregar m√°s funcionalidades a esta clase. Lo que este principio nos incita es a crear una nueva clase, heredando o componiendo la anterior para agregar funcionalidades, en lugar de modificarla la ya existente. De manera que reutilicemos el c√≥digo (abierto a la extensi√≥n), sin modificarlo (cerrado para la modificaci√≥n)

### Liskov‚Äôs Substitution Principle:

> ‚Äúobjetos de un programa deber√≠an ser reemplazables por instancias de sus subtipos sin alterar el correcto funcionamiento del programa‚Äù

Ahora se pone un poquito m√°s complejo‚Ä¶ por su nombre, que viene quien lo formulo por primera ves, Barbara Liskov, y porque es complicado de explicar en palabras, pero lo vamos a intentar‚Ä¶

Supongamos que, por ejemplo, como le√≠mos en open/close principle, extendimos la funcionalidad de una clase P, creando H a partir de P. Este principio nos dice que, si lo hacemos bien, debemos poder sustituir todas las instancias de P, con H. Es decir que la clase ‚Äúhija‚Äù H no pierde o cambia la funcionalidad su clase padre P.

### Interface segregation principle.

> ‚Äúmuchas interfaces cliente espec√≠ficas son mejores que una interfaz de prop√≥sito general‚Äù

El objetivo de este principio es que ning√∫n cliente dependa de m√©todos que no usa. Es decir que hay que evitar que cuando se implemente una interfaz hay que implementar much√≠simos m√©todos que no son necesarios. En cambio, si podemos tratar de implementar muchas interfaces en la aplicaci√≥n que si los necesite.

### Dependency Inversion

> ‚Äúdepender de abstracciones, no depender de implementaciones concretas‚Äù

Esto es que los m√≥dulos de alto nivel no deber√≠an depender de los de bajo nivel. Ambos deber√≠an depender de abstracciones. La forma m√°s cl√°sica es apoyarse en interfaces, que definen un contrato, pero no implementan la l√≥gica. Esto facilita la modificaci√≥n y substituci√≥n de implementaciones


## No seas STUPID!

As√≠ como tenemos reglas nemot√©cnicas para lo que hay que hacer, tenemos algunas para lo que hay que evitar. Una de ellas es STUPID, que es un conjunto de anti-patrones de los que hay que huir:

* **Singleton**: Es su momento fue incentivado como un patr√≥n de dise√±o que evita exponer los colaboradores de una clase. Y que hoy en d√≠a se lo ve como algo negativo ya que hace m√°s dif√≠cil de detectar el acoplamiento entre clases. Se prefiere sustituir con una conveniente v√≠a inyecci√≥n de dependencias. Esto adem√°s facilita la testabilidad.

* **Tight Coupling**: Acoplamiento entre clases que dificulta la mantenibilidad y tolerancia al cambio que proporciona la aplicaci√≥n de principios SOLID

* **Untestability**: C√≥digo dif√≠cil de testear, o c√≥digo altamente acoplado que para poder testar se necesitan generar muchos mocks.

* **Premature Optimization**: Sucede cuando se intentan anticipar requisitos de nuestro software desarrollando abstracciones innecesarias que a√±aden complejidad.

* **Indescriptive Naming**: Nomenclatura poco descriptiva tanto a nivel de clases, como variables o atributos. Esta va en contra de lo que se conoce como Clean Code.

* **Duplication**: Duplicidad de c√≥digo. Algo que los principios SOLID tratan de solucionar.

## Importancia e implementaci√≥n

Los principios de SOLID se han ganado mucha reputaci√≥n y han demostrado que, si son bien implementados, permiten generar c√≥digo mantenible, f√°cil de interpretar y escalable. Si bien los principios est√°n basados en programaci√≥n orientada a objetos, actualmente se extendido, con ciertas licencias, su significado a m√≥dulos m√°s grandes, como un microservicio, o m√°s peque√±os, inclusos algunos pueden implementarse para funciones.

Tambi√©n es cierto que generan cierto hype y que son preguntas est√°ndares de entrevistas en empresas donde, a la hora de escribir c√≥digo, no son tan tenidos en cuenta ü§∑‚Äç‚ôÇÔ∏è. Vale la pena aclarar que estas reglas por si solas no aseguran un buen c√≥digo. Otras reglas como las agrupadas en clean code u implementar patrones de dise√±o en casos concretos tambi√©n ayudan a la mantenibilidad y escalabilidad del c√≥digo. Al mismo tiempo que implementaciones demasiado meticulosas, puede llevar a complejizar demasiado un trabajo, o causar demoras innecesarias.

Como siempre, hay que tener en cuenta el contexto y ver hasta qu√© nivel queremos desgranar una aplicaci√≥n. Por ejemplo, la idea de ‚Äúresponsabilidad √∫nica‚Äù puede depender de que la interpretaci√≥n que tenemos cada desarrollador. Por ejemplo, crear un servicio cuya √∫nica responsabilidad se cambiar el estado de una orden de compra. Esto puede parecer bastante bien en cierto contexto. Sin embargo, una aplicaci√≥n de gesti√≥n de ventas el caso de uso ‚Äúcambiar a estado aprobado‚Äù puede ser muy diferente del ‚Äúcambiar a estado rechazado‚Äù. Las validaciones que necesitemos para ambos casos, o los eventos que podemos disparar luego de este cambio pueden ser muy diferentes. Tal vez una mejor aproximaci√≥n ser√≠a una funci√≥n con la √∫nica responsabilidad de aprobar ordenes de compras, y otra con la √∫nica responsabilidad de rechazarlos.

Al final de cuentas nos encontramos que la aplicaci√≥n de estos principios depende del contexto en que lo utilizamos y eso puede generar muchos dolores de cabezas.
