<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><link rel="stylesheet" href="./_next/static/css/75dd5876a2dd1cff.css" data-precedence="next"/><link rel="stylesheet" href="./_next/static/css/87610fbfb7f110a4.css" data-precedence="next"/><link rel="preload" href="./_next/static/chunks/webpack-49f169d2dc5d61d3.js" as="script"/><link rel="preload" href="./_next/static/chunks/fd9d1056-d05980fb1bd4117c.js" as="script"/><link rel="preload" href="./_next/static/chunks/596-1aa0b84edd7f9576.js" as="script"/><link rel="preload" href="./_next/static/chunks/main-app-cea95c7fbe9d8ccb.js" as="script"/><title>mstefa blog</title><meta name="description" content="Matias Stefanutti personal Blog"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="593x457"/><script src="./_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body><html lang="en"><body><div class="slug_blogPageContainer__FU_0N"><h1 class="article-title">Solid<!-- --> </h1><p class="slug_date__9gvYI">23 May 2022<!-- --> ‚Äî<!-- --> <!-- -->7 min read</p><div class="content"><div> <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/styles/github-dark.min.css"/> <p>Solid es un acr√≥nimo nemot√©cnico de cinco principios reconocidos para generar c√≥digo autodocumentado, flexible y mantenible. Estos cincos principios son una selecci√≥n de principios publicados por Robert C. Martin, uncle Bob para los amigos üòú, en un art√≠culo del 2000 titulado Design Principles and Design Patterns.</p>
<p>Si bien uncle Bob no invento estos principios, √©l fue quien los agrupo sistem√°ticamente. En su art√≠culo que cualquier aplicaci√≥n, por m√°s eficiente o exitosa que sea en su tarea, siempre va a sufrir cambios a lo largo de su vida √∫til pudiendo ir degrad√°ndose, si no se siguen ciertos lineamientos para evitarlo.</p>
<h2>Los Cinco principios</h2>
<h3>Single Responsibility:</h3>
<blockquote>
<p>‚Äúnunca debe haber m√°s de una raz√≥n para que un m√≥dulo cambie‚Äù</p>
</blockquote>
<p>Este es el principio m√°s sencillo de entender. Que haga una sola cosa, y la haga bien. Aunque es probable que diferentes personas pueden interpretarlo de diferente manera. Es decir, ¬øcomo definimos una responsabilidad √∫nica?</p>
<h3>Open/Closed Principle</h3>
<blockquote>
<p>‚ÄúUn m√≥dulo debe estar abierto para la extensi√≥n, pero cerrado para la modificaci√≥n‚Äù</p>
</blockquote>
<p>El ejemplo m√°s tradicional es el siguiente. Supongamos que para un nuevo feature de nuestra app podemos reutilizar los m√©todos de una clase ya existente. Pero para nuestro nuevo caso tambi√©n necesitamos agregar m√°s funcionalidades a esta clase. Lo que este principio nos incita es a crear una nueva clase, heredando o componiendo la anterior para agregar funcionalidades, en lugar de modificarla la ya existente. De manera que reutilicemos el c√≥digo (abierto a la extensi√≥n), sin modificarlo (cerrado para la modificaci√≥n)</p>
<h3>Liskov‚Äôs Substitution Principle:</h3>
<blockquote>
<p>‚Äúobjetos de un programa deber√≠an ser reemplazables por instancias de sus subtipos sin alterar el correcto funcionamiento del programa‚Äù</p>
</blockquote>
<p>Ahora se pone un poquito m√°s complejo‚Ä¶ por su nombre, que viene quien lo formulo por primera ves, Barbara Liskov, y porque es complicado de explicar en palabras, pero lo vamos a intentar‚Ä¶</p>
<p>Supongamos que, por ejemplo, como le√≠mos en open/close principle, extendimos la funcionalidad de una clase P, creando H a partir de P. Este principio nos dice que, si lo hacemos bien, debemos poder sustituir todas las instancias de P, con H. Es decir que la clase ‚Äúhija‚Äù H no pierde o cambia la funcionalidad su clase padre P.</p>
<h3>Interface segregation principle.</h3>
<blockquote>
<p>‚Äúmuchas interfaces cliente espec√≠ficas son mejores que una interfaz de prop√≥sito general‚Äù</p>
</blockquote>
<p>El objetivo de este principio es que ning√∫n cliente dependa de m√©todos que no usa. Es decir que hay que evitar que cuando se implemente una interfaz hay que implementar much√≠simos m√©todos que no son necesarios. En cambio, si podemos tratar de implementar muchas interfaces en la aplicaci√≥n que si los necesite.</p>
<h3>Dependency Inversion</h3>
<blockquote>
<p>‚Äúdepender de abstracciones, no depender de implementaciones concretas‚Äù</p>
</blockquote>
<p>Esto es que los m√≥dulos de alto nivel no deber√≠an depender de los de bajo nivel. Ambos deber√≠an depender de abstracciones. La forma m√°s cl√°sica es apoyarse en interfaces, que definen un contrato, pero no implementan la l√≥gica. Esto facilita la modificaci√≥n y substituci√≥n de implementaciones</p>
<h2>No seas STUPID!</h2>
<p>As√≠ como tenemos reglas nemot√©cnicas para lo que hay que hacer, tenemos algunas para lo que hay que evitar. Una de ellas es STUPID, que es un conjunto de anti-patrones de los que hay que huir:</p>
<ul>
<li>
<p><strong>Singleton</strong>: Es su momento fue incentivado como un patr√≥n de dise√±o que evita exponer los colaboradores de una clase. Y que hoy en d√≠a se lo ve como algo negativo ya que hace m√°s dif√≠cil de detectar el acoplamiento entre clases. Se prefiere sustituir con una conveniente v√≠a inyecci√≥n de dependencias. Esto adem√°s facilita la testabilidad.</p>
</li>
<li>
<p><strong>Tight Coupling</strong>: Acoplamiento entre clases que dificulta la mantenibilidad y tolerancia al cambio que proporciona la aplicaci√≥n de principios SOLID</p>
</li>
<li>
<p><strong>Untestability</strong>: C√≥digo dif√≠cil de testear, o c√≥digo altamente acoplado que para poder testar se necesitan generar muchos mocks.</p>
</li>
<li>
<p><strong>Premature Optimization</strong>: Sucede cuando se intentan anticipar requisitos de nuestro software desarrollando abstracciones innecesarias que a√±aden complejidad.</p>
</li>
<li>
<p><strong>Indescriptive Naming</strong>: Nomenclatura poco descriptiva tanto a nivel de clases, como variables o atributos. Esta va en contra de lo que se conoce como Clean Code.</p>
</li>
<li>
<p><strong>Duplication</strong>: Duplicidad de c√≥digo. Algo que los principios SOLID tratan de solucionar.</p>
</li>
</ul>
<h2>Importancia e implementaci√≥n</h2>
<p>Los principios de SOLID se han ganado mucha reputaci√≥n y han demostrado que, si son bien implementados, permiten generar c√≥digo mantenible, f√°cil de interpretar y escalable. Si bien los principios est√°n basados en programaci√≥n orientada a objetos, actualmente se extendido, con ciertas licencias, su significado a m√≥dulos m√°s grandes, como un microservicio, o m√°s peque√±os, inclusos algunos pueden implementarse para funciones.</p>
<p>Tambi√©n es cierto que generan cierto hype y que son preguntas est√°ndares de entrevistas en empresas donde, a la hora de escribir c√≥digo, no son tan tenidos en cuenta ü§∑‚Äç‚ôÇÔ∏è. Vale la pena aclarar que estas reglas por si solas no aseguran un buen c√≥digo. Otras reglas como las agrupadas en clean code u implementar patrones de dise√±o en casos concretos tambi√©n ayudan a la mantenibilidad y escalabilidad del c√≥digo. Al mismo tiempo que implementaciones demasiado meticulosas, puede llevar a complejizar demasiado un trabajo, o causar demoras innecesarias.</p>
<p>Como siempre, hay que tener en cuenta el contexto y ver hasta qu√© nivel queremos desgranar una aplicaci√≥n. Por ejemplo, la idea de ‚Äúresponsabilidad √∫nica‚Äù puede depender de que la interpretaci√≥n que tenemos cada desarrollador. Por ejemplo, crear un servicio cuya √∫nica responsabilidad se cambiar el estado de una orden de compra. Esto puede parecer bastante bien en cierto contexto. Sin embargo, una aplicaci√≥n de gesti√≥n de ventas el caso de uso ‚Äúcambiar a estado aprobado‚Äù puede ser muy diferente del ‚Äúcambiar a estado rechazado‚Äù. Las validaciones que necesitemos para ambos casos, o los eventos que podemos disparar luego de este cambio pueden ser muy diferentes. Tal vez una mejor aproximaci√≥n ser√≠a una funci√≥n con la √∫nica responsabilidad de aprobar ordenes de compras, y otra con la √∫nica responsabilidad de rechazarlos.</p>
<p>Al final de cuentas nos encontramos que la aplicaci√≥n de estos principios depende del contexto en que lo utilizamos y eso puede generar muchos dolores de cabezas.</p>;</div></div></div></body></html><script src="./_next/static/chunks/webpack-49f169d2dc5d61d3.js" async=""></script><script src="./_next/static/chunks/fd9d1056-d05980fb1bd4117c.js" async=""></script><script src="./_next/static/chunks/596-1aa0b84edd7f9576.js" async=""></script><script src="./_next/static/chunks/main-app-cea95c7fbe9d8ccb.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"0:\"$L1\"\n"])</script><script>self.__next_f.push([1,"2:HL[\"./_next/static/css/75dd5876a2dd1cff.css\",{\"as\":\"style\"}]\n3:HL[\"./_next/static/css/87610fbfb7f110a4.css\",{\"as\":\"style\"}]\n"])</script><script>self.__next_f.push([1,"4:I{\"id\":7948,\"chunks\":[\"272:static/chunks/webpack-49f169d2dc5d61d3.js\",\"971:static/chunks/fd9d1056-d05980fb1bd4117c.js\",\"596:static/chunks/596-1aa0b84edd7f9576.js\"],\"name\":\"default\",\"async\":false}\n6:I{\"id\":6628,\"chunks\":[\"272:static/chunks/webpack-49f169d2dc5d61d3.js\",\"971:static/chunks/fd9d1056-d05980fb1bd4117c.js\",\"596:static/chunks/596-1aa0b84edd7f9576.js\"],\"name\":\"\",\"async\":false}\n7:I{\"id\":7767,\"chunks\":[\"272:static/chunks/webpack-49f169d2dc5d61d3.js\",\"971:static/chunks/fd9d1056-d05980fb1bd4117c.js\",\"5"])</script><script>self.__next_f.push([1,"96:static/chunks/596-1aa0b84edd7f9576.js\"],\"name\":\"default\",\"async\":false}\n8:I{\"id\":7920,\"chunks\":[\"272:static/chunks/webpack-49f169d2dc5d61d3.js\",\"971:static/chunks/fd9d1056-d05980fb1bd4117c.js\",\"596:static/chunks/596-1aa0b84edd7f9576.js\"],\"name\":\"default\",\"async\":false}\n"])</script><script>self.__next_f.push([1,"1:[[],[\"$\",\"$L4\",null,{\"buildId\":\"yBV945JAR-jCTaC83RDyd\",\"assetPrefix\":\".\",\"initialCanonicalUrl\":\"/blog/solid\",\"initialTree\":[\"\",{\"children\":[\"blog\",{\"children\":[[\"slug\",\"solid\",\"d\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":\\\"solid\\\"}\",{}]}]}]},\"$undefined\",\"$undefined\",true],\"initialHead\":\"$L5\",\"globalErrorComponent\":\"$6\",\"children\":[null,[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"children\":[\"$\",\"$L7\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":\"$undefined\",\"childProp\":{\"current\":[null,[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"children\":[\"$\",\"$L7\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"blog\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"childProp\":{\"current\":[\"$\",\"$L7\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"blog\",\"children\",[\"slug\",\"solid\",\"d\"],\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"childProp\":{\"current\":[\"$L9\",\"$La\",null],\"segment\":\"__PAGE__?{\\\"slug\\\":\\\"solid\\\"}\"},\"styles\":[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"./_next/static/css/87610fbfb7f110a4.css\",\"precedence\":\"next\"}]]}],\"segment\":[\"slug\",\"solid\",\"d\"]},\"styles\":[]}]}]}],null],\"segment\":\"blog\"},\"styles\":[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"./_next/static/css/75dd5876a2dd1cff.css\",\"precedence\":\"next\"}]]}]}]}],null]}]]\n"])</script><script>self.__next_f.push([1,"b:I{\"id\":8406,\"chunks\":[\"308:static/chunks/app/blog/[slug]/page-4ce47b6116312b4f.js\"],\"name\":\"MdxContent\",\"async\":false}\nc:T27fd,"])</script><script>self.__next_f.push([1,"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    h2: \"h2\",\n    h3: \"h3\",\n    blockquote: \"blockquote\",\n    ul: \"ul\",\n    li: \"li\",\n    strong: \"strong\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"Solid es un acr√≥nimo nemot√©cnico de cinco principios reconocidos para generar c√≥digo autodocumentado, flexible y mantenible. Estos cincos principios son una selecci√≥n de principios publicados por Robert C. Martin, uncle Bob para los amigos üòú, en un art√≠culo del 2000 titulado Design Principles and Design Patterns.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Si bien uncle Bob no invento estos principios, √©l fue quien los agrupo sistem√°ticamente. En su art√≠culo que cualquier aplicaci√≥n, por m√°s eficiente o exitosa que sea en su tarea, siempre va a sufrir cambios a lo largo de su vida √∫til pudiendo ir degrad√°ndose, si no se siguen ciertos lineamientos para evitarlo.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Los Cinco principios\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Single Responsibility:\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"‚Äúnunca debe haber m√°s de una raz√≥n para que un m√≥dulo cambie‚Äù\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Este es el principio m√°s sencillo de entender. Que haga una sola cosa, y la haga bien. Aunque es probable que diferentes personas pueden interpretarlo de diferente manera. Es decir, ¬øcomo definimos una responsabilidad √∫nica?\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Open/Closed Principle\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"‚ÄúUn m√≥dulo debe estar abierto para la extensi√≥n, pero cerrado para la modificaci√≥n‚Äù\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"El ejemplo m√°s tradicional es el siguiente. Supongamos que para un nuevo feature de nuestra app podemos reutilizar los m√©todos de una clase ya existente. Pero para nuestro nuevo caso tambi√©n necesitamos agregar m√°s funcionalidades a esta clase. Lo que este principio nos incita es a crear una nueva clase, heredando o componiendo la anterior para agregar funcionalidades, en lugar de modificarla la ya existente. De manera que reutilicemos el c√≥digo (abierto a la extensi√≥n), sin modificarlo (cerrado para la modificaci√≥n)\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Liskov‚Äôs Substitution Principle:\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"‚Äúobjetos de un programa deber√≠an ser reemplazables por instancias de sus subtipos sin alterar el correcto funcionamiento del programa‚Äù\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Ahora se pone un poquito m√°s complejo‚Ä¶ por su nombre, que viene quien lo formulo por primera ves, Barbara Liskov, y porque es complicado de explicar en palabras, pero lo vamos a intentar‚Ä¶\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Supongamos que, por ejemplo, como le√≠mos en open/close principle, extendimos la funcionalidad de una clase P, creando H a partir de P. Este principio nos dice que, si lo hacemos bien, debemos poder sustituir todas las instancias de P, con H. Es decir que la clase ‚Äúhija‚Äù H no pierde o cambia la funcionalidad su clase padre P.\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Interface segregation principle.\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"‚Äúmuchas interfaces cliente espec√≠ficas son mejores que una interfaz de prop√≥sito general‚Äù\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"El objetivo de este principio es que ning√∫n cliente dependa de m√©todos que no usa. Es decir que hay que evitar que cuando se implemente una interfaz hay que implementar much√≠simos m√©todos que no son necesarios. En cambio, si podemos tratar de implementar muchas interfaces en la aplicaci√≥n que si los necesite.\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Dependency Inversion\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"‚Äúdepender de abstracciones, no depender de implementaciones concretas‚Äù\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Esto es que los m√≥dulos de alto nivel no deber√≠an depender de los de bajo nivel. Ambos deber√≠an depender de abstracciones. La forma m√°s cl√°sica es apoyarse en interfaces, que definen un contrato, pero no implementan la l√≥gica. Esto facilita la modificaci√≥n y substituci√≥n de implementaciones\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"No seas STUPID!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"As√≠ como tenemos reglas nemot√©cnicas para lo que hay que hacer, tenemos algunas para lo que hay que evitar. Una de ellas es STUPID, que es un conjunto de anti-patrones de los que hay que huir:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"Singleton\"\n          }), \": Es su momento fue incentivado como un patr√≥n de dise√±o que evita exponer los colaboradores de una clase. Y que hoy en d√≠a se lo ve como algo negativo ya que hace m√°s dif√≠cil de detectar el acoplamiento entre clases. Se prefiere sustituir con una conveniente v√≠a inyecci√≥n de dependencias. Esto adem√°s facilita la testabilidad.\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"Tight Coupling\"\n          }), \": Acoplamiento entre clases que dificulta la mantenibilidad y tolerancia al cambio que proporciona la aplicaci√≥n de principios SOLID\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"Untestability\"\n          }), \": C√≥digo dif√≠cil de testear, o c√≥digo altamente acoplado que para poder testar se necesitan generar muchos mocks.\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"Premature Optimization\"\n          }), \": Sucede cuando se intentan anticipar requisitos de nuestro software desarrollando abstracciones innecesarias que a√±aden complejidad.\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"Indescriptive Naming\"\n          }), \": Nomenclatura poco descriptiva tanto a nivel de clases, como variables o atributos. Esta va en contra de lo que se conoce como Clean Code.\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"Duplication\"\n          }), \": Duplicidad de c√≥digo. Algo que los principios SOLID tratan de solucionar.\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Importancia e implementaci√≥n\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Los principios de SOLID se han ganado mucha reputaci√≥n y han demostrado que, si son bien implementados, permiten generar c√≥digo mantenible, f√°cil de interpretar y escalable. Si bien los principios est√°n basados en programaci√≥n orientada a objetos, actualmente se extendido, con ciertas licencias, su significado a m√≥dulos m√°s grandes, como un microservicio, o m√°s peque√±os, inclusos algunos pueden implementarse para funciones.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Tambi√©n es cierto que generan cierto hype y que son preguntas est√°ndares de entrevistas en empresas donde, a la hora de escribir c√≥digo, no son tan tenidos en cuenta ü§∑‚Äç‚ôÇÔ∏è. Vale la pena aclarar que estas reglas por si solas no aseguran un buen c√≥digo. Otras reglas como las agrupadas en clean code u implementar patrones de dise√±o en casos concretos tambi√©n ayudan a la mantenibilidad y escalabilidad del c√≥digo. Al mismo tiempo que implementaciones demasiado meticulosas, puede llevar a complejizar demasiado un trabajo, o causar demoras innecesarias.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Como siempre, hay que tener en cuenta el contexto y ver hasta qu√© nivel queremos desgranar una aplicaci√≥n. Por ejemplo, la idea de ‚Äúresponsabilidad √∫nica‚Äù puede depender de que la interpretaci√≥n que tenemos cada desarrollador. Por ejemplo, crear un servicio cuya √∫nica responsabilidad se cambiar el estado de una orden de compra. Esto puede parecer bastante bien en cierto contexto. Sin embargo, una aplicaci√≥n de gesti√≥n de ventas el caso de uso ‚Äúcambiar a estado aprobado‚Äù puede ser muy diferente del ‚Äúcambiar a estado rechazado‚Äù. Las validaciones que necesitemos para ambos casos, o los eventos que podemos disparar luego de este cambio pueden ser muy diferentes. Tal vez una mejor aproximaci√≥n ser√≠a una funci√≥n con la √∫nica responsabilidad de aprobar ordenes de compras, y otra con la √∫nica responsabilidad de rechazarlos.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Al final de cuentas nos encontramos que la aplicaci√≥n de estos principios depende del contexto en que lo utilizamos y eso puede generar muchos dolores de cabezas.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n"])</script><script>self.__next_f.push([1,"a:[\"$\",\"div\",null,{\"className\":\"slug_blogPageContainer__FU_0N\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"article-title\",\"children\":[\"Solid\",\" \"]}],[\"$\",\"p\",null,{\"className\":\"slug_date__9gvYI\",\"children\":[\"23 May 2022\",\" ‚Äî\",\" \",\"7 min read\"]}],[\"$\",\"div\",null,{\"className\":\"content\",\"children\":[\"$\",\"$Lb\",null,{\"source\":{\"compiledSource\":\"$c\",\"frontmatter\":{\"title\":\"Solid\",\"published_at\":\"2022-05-23\",\"excerpt\":\"Solid es un acr√≥nimo nemot√©cnico de cinco principios reconocidos para generar c√≥digo autodocumentado, flexible y mantenible. Estos cincos principios son una selecci√≥n de principios publicados por Robert C. Martin, en un art√≠culo del 2000 titulado Design Principles and Design Patterns.\",\"cover_image\":\"path/to/where/image/is/stored\"},\"scope\":{}}}]}]]}]\n"])</script><script>self.__next_f.push([1,"5:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"1\",{\"children\":\"mstefa blog\"}],[\"$\",\"meta\",\"2\",{\"name\":\"description\",\"content\":\"Matias Stefanutti personal Blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"link\",\"4\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"593x457\"}]]\n9:null\n"])</script></body></html>